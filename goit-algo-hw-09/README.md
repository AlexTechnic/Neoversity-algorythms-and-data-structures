# Опис домашнього завдання

У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет [50, 25, 10, 5, 2, 1]. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

### Функція жадібного алгоритму find_coins_greedy. 
Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.

### Функція динамічного програмування find_min_coins. 
Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}

Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл readme.md домашнього завдання.

# Критерії прийняття ДЗ

Програмно реалізовано функцію, яка використовує принцип жадібного алгоритму. Код виконується і повертає словник з кількістю монет кожного номіналу, що використовуються для формування певної суми. Спочатку вибираються найбільш доступні номінали монет.

Програмно реалізовано функцію, яка використовує принцип динамічного програмування. Код виконується і повертає словник з номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом.

На основі оцінювання часу виконання кожного з двох алгоритмів або О великого визначено найбільш ефективний при великих сумах алгоритм.

Зроблено висновки щодо ефективності алгоритмів для даного випадку. Висновки оформлено у вигляді файлу readme.md домашнього завдання.

# Результати:

Результат жадібного алгоритму для видачі решти для суми 113: {50: 2, 10: 1, 2: 1, 1: 1} (Кількість монет: 5)

Результат динамічного програмування для видачі решти для суми 113: {50: 2, 10: 1, 2: 1, 1: 1} (Кількість монет: 5)

Згенеровані випадкові суми для порвіняння швидкості виконання: [95, 151, 483, 497, 863]

Amount || Greedy: s | сoins || DP:     s |  сoins
    95 || 0.0006727 |     4 || 0.0829640 |      4
   151 || 0.0005773 |     4 || 0.1287578 |      4
   483 || 0.0009742 |    13 || 0.4733289 |     13
   497 || 0.0007661 |    13 || 0.4507949 |     13
   863 || 0.0012116 |    20 || 0.8812348 |     20

## Оцінка ефективності

### Жадібний алгоритм (Greedy Algorithm)

- **Часова складність:** O(n)

- **Переваги:** 
  - Дуже швидкий, працює в лінійний час щодо кількості монет.
  - Ідеально підходить для великих сум, коли важлива швидкість обчислень.

- **Недоліки:** 
  - Може не завжди забезпечувати мінімальну кількість монет, якщо номінали монет не є кратними.

### Алгоритм динамічного програмування (Dynamic Programming)

- **Часова складність:** O(n \times m)

- **Переваги:** 
  - Завжди знаходить мінімальну кількість монет.
  - Підходить для будь-якого набору монет, навіть якщо номінали не є кратними.

- **Недоліки:** 
  - Час виконання значно зростає при збільшенні суми.
  - Менш ефективний для великих сум у порівнянні з жадібним алгоритмом.

## Висновки

- **Жадібний алгоритм:** Рекомендується використовувати для задач, де важлива швидкість і набір монет дозволяє отримати близьке до оптимального рішення.

- **Алгоритм динамічного програмування:** Підходить для задач, де важливо знайти абсолютно мінімальну кількість монет, але час виконання не є критичним фактором.